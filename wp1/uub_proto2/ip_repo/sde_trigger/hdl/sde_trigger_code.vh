// sde_trigger_code.vh
// 
// This is the code portion of the sde_trigger that is included into
// the base sde_trigger_vM_N_S00_AXI.v AXI peripheral generated by Vivado.
// This keeps the guts of our trigger code separated from all the AXI
// register interface code.
// 
// 08-Aug-2014 DFN Initial version.
// 26-Feb-2016 DFN Add external trigger
// 06-Apr-2016 DFN Change to put each ADC in its own 16 bit field to simplify
//                 unpacking.

reg [1:0] ENABLE40;
wire COMPATIBILITY_SB_TRIG;
reg [`SHWR_TRIG_DLY:0] SHWR_TRIG_DLYD; // Trigger delayed to end of buf
reg [`SHWR_DEAD_DLY:0] SHWR_DEAD_DLYD; // Dead time after end of buf

reg [`SHWR_MEM_NBUF-1:0] SHWR_BUF_RESET;
reg [`SHWR_BUF_NUM_WIDTH:0] SHWR_BUF_NUM_FULL;
reg [`SHWR_MEM_ADDR_WIDTH-1:0] SHWR_ADDR1;
reg [`SHWR_MEM_NBUF-1:0] SHWR_BUF_FULL_FLAGS;
wire [31:0] LCL_SHWR_BUF_CONTROL;
reg [31:0] LCL_SHWR_BUF_START;
reg [31:0] LCL_SHWR_BUF_STARTT;
reg [`SHWR_MEM_BUF_SHIFT+
     `SHWR_BUF_NUM_WIDTH-1:0] LCL_SHWR_BUF_STARTN[0:`SHWR_MEM_NBUF-1];
reg AXI_REG_WRITE;
reg AXI_SHWR_CONTROL_WRITTEN;
reg AXI_MUON_CONTROL_WRITTEN;
wire LCL_SHWR_CONTROL_WRITTEN;
reg PREV_SHWR_CONTROL_WRITTEN;
reg [31:0] LCL_SHWR_BUF_STATUS;
reg [31:0] LCL_SHWR_BUF_TRIG_ID;
reg [14:0] LCL_SHWR_BUF_TRIG_IDN[0:`SHWR_MEM_NBUF-1];
wire [31:0] LCL_COMPATIBILITY_GLOBAL_CONTROL;
reg TRIG_IN_PREV;
reg EXT_TRIG;
reg [3:0] ADC_EXTRA;
reg [`ADC_WIDTH-1:0] FILTB_PMT0, FILTB_PMT1, FILTB_PMT2;
reg [`ADC_WIDTH+1:0] FILTD_PMT0, FILTD_PMT1, FILTD_PMT2;

reg [`MUON_NUM_TRIGS-1:0] MUON_PRETRIG;
reg [`MUON_EXT_TRIG_DELAY:0] MUON_EXT_TRIG;
wire MUON_PRETRIG1, MUON_PRETRIG2, MUON_PRETRIG3, MUON_PRETRIG4;
reg LCL_RESET;
wire [4:0] MUON1_DEBUG, MUON2_DEBUG, MUON3_DEBUG, MUON4_DEBUG;
wire [4:0] MUON_BUFFER_DEBUG;
wire [4:0] LED_DEBUG;
wire LED_TRG_FLAG;
wire [31:0] LCL_LED_CONTROL;
reg TRIGGERED;
reg [31:0] SOME_TRIG;
reg [31:0] SOME_DLYD_TRIG;
reg [7:0] COMPAT_SB_TRIG_COUNTER;
reg [7:0] COMPAT_EXT_TRIG_COUNTER;
reg PRESCALED_COMPAT_SB_TRIG;
reg PRESCALED_COMPAT_EXT_TRIG;

integer INDEX;
integer DELAY;
integer DEADDLY;
integer MUON_EXTDLY;

// Generate compatibility mode triggers.
// Some debug included below
single_bin_40mhz 
  sb_40mhz1(.ENABLE40(ENABLE40),
	    .CLK120(CLK120),
	    .ADC0(FILTB_PMT0),
	    .ADC1(FILTB_PMT1),
	    .ADC2(FILTB_PMT2),
	    .THRES0(COMPATIBILITY_SB_TRIG_THR0[`ADC_WIDTH-1:0]),
	    .THRES1(COMPATIBILITY_SB_TRIG_THR1[`ADC_WIDTH-1:0]),
	    .THRES2(COMPATIBILITY_SB_TRIG_THR2[`ADC_WIDTH-1:0]),
	    .TRIG_ENABLE(COMPATIBILITY_SB_TRIG_ENAB
                         [`COMPATIBILITY_SB_TRIG_ENAB_SHIFT+
                          `COMPATIBILITY_SB_TRIG_ENAB_WIDTH-1:
                          `COMPATIBILITY_SB_TRIG_ENAB_SHIFT]),
	    .MULTIPLICITY(COMPATIBILITY_SB_TRIG_ENAB
                          [`COMPATIBILITY_SB_TRIG_COINC_LVL_SHIFT+
                           `COMPATIBILITY_SB_TRIG_COINC_LVL_WIDTH-1:
                           `COMPATIBILITY_SB_TRIG_COINC_LVL_SHIFT]),
	    .TRIG(COMPATIBILITY_SB_TRIG)
	    );

// Generate muon triggers

muon_trigger
  muon_trigger1(.RESET(LCL_RESET),
                .CLK120(CLK120),
	        .ADC0(ADC0[2*`ADC_WIDTH-1:`ADC_WIDTH]),
	        .ADC1(ADC1[2*`ADC_WIDTH-1:`ADC_WIDTH]),
	        .ADC2(ADC2[2*`ADC_WIDTH-1:`ADC_WIDTH]),
                .ADC_SSD(ADC4[2*`ADC_WIDTH-1:`ADC_WIDTH]),
	        .TRIG_THR0(MUON_TRIG1_THR0[`ADC_WIDTH-1:0]),
	        .TRIG_THR1(MUON_TRIG1_THR1[`ADC_WIDTH-1:0]),
	        .TRIG_THR2(MUON_TRIG1_THR2[`ADC_WIDTH-1:0]),
	        .TRIG_SSD(MUON_TRIG1_SSD[`ADC_WIDTH-1:0]),
	        .TRIG_ENAB(MUON_TRIG1_ENAB),
                .TRIG(MUON_PRETRIG1),
                .DEBUG(MUON1_DEBUG)
  	        );
muon_trigger
  muon_trigger2(.RESET(LCL_RESET),
                .CLK120(CLK120),
	        .ADC0(ADC0[2*`ADC_WIDTH-1:`ADC_WIDTH]),
	        .ADC1(ADC1[2*`ADC_WIDTH-1:`ADC_WIDTH]),
	        .ADC2(ADC2[2*`ADC_WIDTH-1:`ADC_WIDTH]),
                .ADC_SSD(ADC4[2*`ADC_WIDTH-1:`ADC_WIDTH]),
	        .TRIG_THR0(MUON_TRIG2_THR0[`ADC_WIDTH-1:0]),
	        .TRIG_THR1(MUON_TRIG2_THR1[`ADC_WIDTH-1:0]),
	        .TRIG_THR2(MUON_TRIG2_THR2[`ADC_WIDTH-1:0]),
	        .TRIG_SSD(MUON_TRIG2_SSD[`ADC_WIDTH-1:0]),
	        .TRIG_ENAB(MUON_TRIG2_ENAB),
                .TRIG(MUON_PRETRIG2),
                .DEBUG(MUON2_DEBUG)
  	        );
muon_trigger
  muon_trigger3(.RESET(LCL_RESET),
                .CLK120(CLK120),
	        .ADC0(ADC0[2*`ADC_WIDTH-1:`ADC_WIDTH]),
	        .ADC1(ADC1[2*`ADC_WIDTH-1:`ADC_WIDTH]),
	        .ADC2(ADC2[2*`ADC_WIDTH-1:`ADC_WIDTH]),
                .ADC_SSD(ADC4[2*`ADC_WIDTH-1:`ADC_WIDTH]),
	        .TRIG_THR0(MUON_TRIG3_THR0[`ADC_WIDTH-1:0]),
	        .TRIG_THR1(MUON_TRIG3_THR1[`ADC_WIDTH-1:0]),
	        .TRIG_THR2(MUON_TRIG3_THR2[`ADC_WIDTH-1:0]),
	        .TRIG_SSD(MUON_TRIG3_SSD[`ADC_WIDTH-1:0]),
	        .TRIG_ENAB(MUON_TRIG3_ENAB),
                .TRIG(MUON_PRETRIG3),
                .DEBUG(MUON3_DEBUG)
  	        );
muon_trigger
  muon_trigger4(.RESET(LCL_RESET),
                .CLK120(CLK120),
	        .ADC0(ADC0[2*`ADC_WIDTH-1:`ADC_WIDTH]),
	        .ADC1(ADC1[2*`ADC_WIDTH-1:`ADC_WIDTH]),
	        .ADC2(ADC2[2*`ADC_WIDTH-1:`ADC_WIDTH]),
                .ADC_SSD(ADC4[2*`ADC_WIDTH-1:`ADC_WIDTH]),
	        .TRIG_THR0(MUON_TRIG4_THR0[`ADC_WIDTH-1:0]),
	        .TRIG_THR1(MUON_TRIG4_THR1[`ADC_WIDTH-1:0]),
	        .TRIG_THR2(MUON_TRIG4_THR2[`ADC_WIDTH-1:0]),
	        .TRIG_SSD(MUON_TRIG4_SSD[`ADC_WIDTH-1:0]),
	        .TRIG_ENAB(MUON_TRIG4_ENAB),
                .TRIG(MUON_PRETRIG4),
                .DEBUG(MUON4_DEBUG)
  	        );

muon_buffers
  muon_buffers1(.RESET(LCL_RESET),
                .AXI_CLK(S_AXI_ACLK),
                .CLK120(CLK120),
	        .ADC0(ADC0[2*`ADC_WIDTH-1:`ADC_WIDTH]),
	        .ADC1(ADC1[2*`ADC_WIDTH-1:`ADC_WIDTH]),
	        .ADC2(ADC2[2*`ADC_WIDTH-1:`ADC_WIDTH]),
                .ADC_SSD(ADC4[2*`ADC_WIDTH-1:`ADC_WIDTH]),
                .MUON_BUF_CONTROL(MUON_BUF_CONTROL),
                .MUON_BUF_TRIG_MASK(MUON_BUF_TRIG_MASK),
                .AXI_MUON_CONTROL_WRITTEN(AXI_MUON_CONTROL_WRITTEN),
                .AXI_REG_WRITE(AXI_REG_WRITE),
	        .MUON_INTR(MUON_INTR),
                .MUON_ENB(MUON_ENB),
                .MUON_TRIG(MUON_PRETRIG),
                .MUON_BUF_WNUM(MUON_BUF_WNUM),
                .MUON_BUF_RNUM(MUON_BUF_RNUM),
                .MUON_EVT_CTR(MUON_EVT_CTR),
                .MUON_DATA0(MUON_DATA0),
                .MUON_DATA1(MUON_DATA1),
                .MUON_ADDR(MUON_ADDR),
                .MUON_BUF_TIME_TAG_A(MUON_BUF_TIME_TAG_A),
                .MUON_BUF_TIME_TAG_B(MUON_BUF_TIME_TAG_B),
                .MUON_BUF_STATUS(MUON_BUF_STATUS),
                .MUON_BUF_WORD_COUNT(MUON_BUF_WORD_COUNT),
                .DEBUG(MUON_BUFFER_DEBUG)
	        );

// Generate LED pulses
led_control led_control1(.RESET(LCL_RESET),
                         .CLK120(CLK120),
                         .ONE_PPS(ONE_PPS),
                         .LED_CONTROL(LCL_LED_CONTROL),
                         .LEDBAR(LEDBAR),
                         .TRG_FLAG(LED_TRG_FLAG),
                         .DEBUG(LED_DEBUG)
                         );

always @(posedge CLK120) begin
   LCL_RESET <= ((LCL_COMPATIBILITY_GLOBAL_CONTROL &
                  `COMPATIBILITY_GLOBAL_CONTROL_RESET) != 0);
   if (LCL_RESET)
     begin
        ENABLE40 <= 0;
        SHWR_BUF_WNUM <= 0;
        SHWR_BUF_NUM_FULL <= 0;
        SHWR_BUF_FULL_FLAGS <= 0;
        SHWR_BUF_RNUM <= 0;
        SHWR_EVT_CTR <= 0;
        LCL_SHWR_BUF_TRIG_ID <= 0;
        LCL_SHWR_BUF_TRIG_ID <= 0;
        LCL_SHWR_BUF_STATUS <= 0;
        DEAD <= 0;
        SHWR_INTR <= 0;
        SHWR_ADDR1 <= 0;
        TRIG_OUT <= 0;
        EXT_TRIG <= 0;
        ADC_EXTRA <= 0;
        SOME_DLYD_TRIG <= 0;
        TRIGGERED <= 0;
        SOME_TRIG <= 0;
        COMPAT_SB_TRIG_COUNTER <= 0;
        COMPAT_EXT_TRIG_COUNTER <= 0;
        PRESCALED_COMPAT_SB_TRIG <= 0;
        PRESCALED_COMPAT_EXT_TRIG <= 0;
     end
   else
     begin

        // Delay muon external trigger to be approx in sync with single bin
        MUON_EXT_TRIG[0] <= EXT_TRIG;
        for (MUON_EXTDLY = 1; MUON_EXTDLY<=`MUON_EXT_TRIG_DELAY; 
             MUON_EXTDLY = MUON_EXTDLY+1)
          MUON_EXT_TRIG[MUON_EXTDLY] <= MUON_EXT_TRIG[MUON_EXTDLY-1];

        // Form composite trigger for storing muon in muon buffer        
        MUON_PRETRIG = (MUON_PRETRIG1 << `MUON_BUF_TRIG_SB1_SHIFT) |
                       (MUON_PRETRIG2 << `MUON_BUF_TRIG_SB2_SHIFT) | 
                       (MUON_PRETRIG3 <<`MUON_BUF_TRIG_SB3_SHIFT) | 
                       (MUON_PRETRIG4 <<`MUON_BUF_TRIG_SB4_SHIFT) |
                       (MUON_EXT_TRIG[`MUON_EXT_TRIG_DELAY] <<
                       `MUON_BUF_TRIG_EXT_SHIFT);

        // Form external trigger on upward transition
        TRIG_IN_PREV <= TRIG_IN;
        EXT_TRIG <= TRIG_IN & !TRIG_IN_PREV;

        // Trig_out
        TRIG_OUT <= SOME_TRIG;
        
        // Handle prescaling of shower triggers
        if (SHWR_BUF_TRIG_MASK & `COMPAT_PRESCALE_SHWR_BUF_TRIG_SB) begin
           if (COMPATIBILITY_SB_TRIG) begin
              COMPAT_SB_TRIG_COUNTER <= COMPAT_SB_TRIG_COUNTER + 1;
              if (COMPAT_SB_TRIG_COUNTER == 0) PRESCALED_COMPAT_SB_TRIG <= 1;
           end
           else
             PRESCALED_COMPAT_SB_TRIG <= 0;
        end
        else
          PRESCALED_COMPAT_SB_TRIG <= COMPATIBILITY_SB_TRIG;

        if (SHWR_BUF_TRIG_MASK & `COMPAT_PRESCALE_SHWR_BUF_TRIG_EXT) begin
           if (EXT_TRIG) begin
              COMPAT_EXT_TRIG_COUNTER <= COMPAT_EXT_TRIG_COUNTER + 1;
              if (COMPAT_EXT_TRIG_COUNTER == 0) PRESCALED_COMPAT_EXT_TRIG <= 1;
              else
                PRESCALED_COMPAT_EXT_TRIG <= 0;
           end
           else
             PRESCALED_COMPAT_EXT_TRIG <= EXT_TRIG;
        end
        
        // Clip filtered signals to remain within 12 bit range
        if (FILT_PMT0[`ADC_WIDTH+1] == 1)
          FILTB_PMT0 <= 0;
        else if (FILT_PMT0[`ADC_WIDTH] == 1)
          FILTB_PMT0 <= (1 << `ADC_WIDTH) -1;
        else
          FILTB_PMT0 = FILT_PMT0[`ADC_WIDTH-1:0];

        if (FILT_PMT1[`ADC_WIDTH+1] == 1)
          FILTB_PMT1 <= 0;
        else if (FILT_PMT1[`ADC_WIDTH] == 1)
          FILTB_PMT1 <= (1 << `ADC_WIDTH) -1;
        else
          FILTB_PMT1 = FILT_PMT1[`ADC_WIDTH-1:0];

        if (FILT_PMT2[`ADC_WIDTH+1] == 1)
          FILTB_PMT2 <= 0;
        else if (FILT_PMT2[`ADC_WIDTH] == 1)
          FILTB_PMT2 <= (1 << `ADC_WIDTH) -1;
        else
          FILTB_PMT2 = FILT_PMT2[`ADC_WIDTH-1:0];

        // Keep a copy of unclipped filtered signal in sync with clipped one.
        FILTD_PMT0 <= FILT_PMT0;
        FILTD_PMT1 <= FILT_PMT1;
        FILTD_PMT2 <= FILT_PMT2;

        // Send shower data to memory
        
        SHWR_ADDR1[`SHWR_MEM_BUF_SHIFT-1:0]
          <= (SHWR_ADDR1+4) & (`SHWR_MEM_DEPTH-1);
        SHWR_ADDR1[`SHWR_MEM_BUF_SHIFT+`SHWR_BUF_NUM_WIDTH-1:
                   `SHWR_MEM_BUF_SHIFT] <= SHWR_BUF_WNUM;
        SHWR_ADDR <= SHWR_ADDR1;
        SHWR_DATA0[`ADC_WIDTH-1:0] <= ADC0[`ADC_WIDTH-1:0];
        SHWR_DATA0[`ADC_WIDTH+15:16] <= ADC0[2*`ADC_WIDTH-1:`ADC_WIDTH];
        SHWR_DATA1[`ADC_WIDTH-1:0] <= ADC1[`ADC_WIDTH-1:0];
        SHWR_DATA1[`ADC_WIDTH+15:16] <= ADC1[2*`ADC_WIDTH-1:`ADC_WIDTH];
        SHWR_DATA2[`ADC_WIDTH-1:0] <= ADC2[`ADC_WIDTH-1:0];
        SHWR_DATA2[`ADC_WIDTH+15:16] <= ADC2[2*`ADC_WIDTH-1:`ADC_WIDTH];
        SHWR_DATA3[`ADC_WIDTH-1:0] <= ADC3[`ADC_WIDTH-1:0];
        SHWR_DATA3[`ADC_WIDTH+15:16] <= ADC3[2*`ADC_WIDTH-1:`ADC_WIDTH];
        SHWR_DATA4[`ADC_WIDTH-1:0] <= ADC4[`ADC_WIDTH-1:0];
        SHWR_DATA4[`ADC_WIDTH+15:16] <= ADC4[2*`ADC_WIDTH-1:`ADC_WIDTH];

        SHWR_DATA0[15:`ADC_WIDTH] <= FILTB_PMT0 & 'hf;
        SHWR_DATA0[31:`ADC_WIDTH+16] <= (FILTB_PMT0 >> 4) & 'hf;
        SHWR_DATA1[15:`ADC_WIDTH] <= (FILTB_PMT0 >> 8) & 'hf;
        SHWR_DATA1[31:`ADC_WIDTH+16] <= FILTB_PMT1 & 'hf;
        SHWR_DATA2[15:`ADC_WIDTH] <= (FILTB_PMT1 >> 4) & 'hf;
        SHWR_DATA2[31:`ADC_WIDTH+16] <= (FILTB_PMT1 >> 8) & 'hf;
        SHWR_DATA3[15:`ADC_WIDTH] <=  FILTB_PMT2 & 'hf;
        SHWR_DATA3[31:`ADC_WIDTH+16] <= (FILTB_PMT2 >> 4) & 'hf;
        SHWR_DATA4[15:`ADC_WIDTH] <=  (FILTB_PMT2 >> 8) & 'hf;
        SHWR_DATA4[31:`ADC_WIDTH+16] <= ADC_EXTRA;
        if (ADC_EXTRA == 14)
          ADC_EXTRA <= 0;
        else
          ADC_EXTRA <= ADC_EXTRA+1;
        
        // Make offset to data in current buffer to read available
        LCL_SHWR_BUF_STARTT[`SHWR_MEM_BUF_SHIFT+`SHWR_BUF_NUM_WIDTH-1:0] 
          <= LCL_SHWR_BUF_STARTN[SHWR_BUF_RNUM];
        LCL_SHWR_BUF_STARTT[31:`SHWR_MEM_BUF_SHIFT+`SHWR_BUF_NUM_WIDTH] = 0;

        // Adjust for logic delay
        LCL_SHWR_BUF_START <= ((LCL_SHWR_BUF_STARTT+12) 
                               & (`SHWR_MEM_DEPTH-1)) >> 2;
        LCL_SHWR_BUF_TRIG_ID <= LCL_SHWR_BUF_TRIG_IDN[SHWR_BUF_RNUM];
        
        // Create enable for downsampling the data.
        if (ENABLE40 == 2)
	  ENABLE40 <= 0;
        else
	  ENABLE40 <= ENABLE40+1;
        
        // Do we have a free buffer? If not, we can't process this trigger.
        // Note that the way this is implemented here we can only fill n-1 of
        // the buffers, or we'll end up overwriting the oldest buffer. So this
        // simple logic will not work well for only 2 buffers. To use all the
        // buffers we would have to turn off the write enable to the dual
        // ported memory if all buffers were full. Let's keep the simple logic
        // for now.
        
        if ((SHWR_BUF_NUM_FULL < `SHWR_MEM_NBUF-1)) begin

           if (!TRIGGERED && !DEAD) begin
              // "or" of first triggers
              SOME_TRIG <=  ((PRESCALED_COMPAT_SB_TRIG << 
                              `COMPATIBILITY_SHWR_BUF_TRIG_SB_SHIFT) &
                             (SHWR_BUF_TRIG_MASK & 
                              `COMPATIBILITY_SHWR_BUF_TRIG_SB)) 
                | ((PRESCALED_COMPAT_EXT_TRIG <<
                    `COMPATIBILITY_SHWR_BUF_TRIG_EXT_SHIFT) & 
                   (SHWR_BUF_TRIG_MASK & `COMPATIBILITY_SHWR_BUF_TRIG_EXT));
              
              if (SOME_TRIG) begin
                 TRIGGERED <= 1;
                 SHWR_TRIG_DLYD[0] <= 1;
                 DEAD <= 1;
                 SHWR_DEAD_DLYD[0] <= 1;

                 // Trigger ID of first trigger. 
                   LCL_SHWR_BUF_TRIG_IDN[SHWR_BUF_WNUM] 
                     <= SOME_TRIG |  (LED_TRG_FLAG << `SHWR_BUF_TRIG_LED_SHIFT);

              end
           end // if (!TRIGGERED && !DEAD)


           // Process dead time
           if (DEAD) begin
              SHWR_DEAD_DLYD[0] <= 0;
              for (DEADDLY = 0; DEADDLY<`SHWR_DEAD_DLY; DEADDLY=DEADDLY+1)
	        SHWR_DEAD_DLYD[DEADDLY+1] <= SHWR_DEAD_DLYD[DEADDLY];     
              if (SHWR_DEAD_DLYD[`SHWR_DEAD_DLY] 
                  < SHWR_DEAD_DLYD[`SHWR_DEAD_DLY-1])
                DEAD <= 0;
           end

           // Process trigger delay 
           if (TRIGGERED) begin
              
              // "or" of delayed triggers
             SOME_DLYD_TRIG <=  ((PRESCALED_COMPAT_SB_TRIG << 
                                  `COMPATIBILITY_SHWR_BUF_TRIG_SB_SHIFT) &
                                 (SHWR_BUF_TRIG_MASK & 
                                  `COMPATIBILITY_SHWR_BUF_TRIG_SB)) 
               | ((PRESCALED_COMPAT_EXT_TRIG << 
                   `COMPATIBILITY_SHWR_BUF_TRIG_EXT_SHIFT) & 
                   (SHWR_BUF_TRIG_MASK & `COMPATIBILITY_SHWR_BUF_TRIG_EXT));
              LCL_SHWR_BUF_TRIG_IDN[SHWR_BUF_WNUM]
                <= LCL_SHWR_BUF_TRIG_IDN[SHWR_BUF_WNUM]
                | SOME_DLYD_TRIG |  (LED_TRG_FLAG << `SHWR_BUF_TRIG_LED_SHIFT);             
 
              // Delay this action to the end of the buffer
 	      SHWR_TRIG_DLYD[0] <= 0;
              for (DELAY = 0; DELAY<`SHWR_TRIG_DLY; DELAY=DELAY+1)
	        SHWR_TRIG_DLYD[DELAY+1] <= SHWR_TRIG_DLYD[DELAY];
              
              // If rising edge, we have a trigger and are at the end of the buffer
              if (SHWR_TRIG_DLYD[`SHWR_TRIG_DLY] < SHWR_TRIG_DLYD[`SHWR_TRIG_DLY-1]) 
	        begin
                   // Mark buffer as full and switch to the next one
	           SHWR_BUF_FULL_FLAGS <= SHWR_BUF_FULL_FLAGS |
                                          (1<<SHWR_BUF_WNUM);
	           SHWR_BUF_NUM_FULL <= SHWR_BUF_NUM_FULL+1;
	           SHWR_BUF_WNUM <= SHWR_BUF_WNUM+1;
                   SHWR_TRIGGER <= 1;
                   SHWR_INTR <= 1;
                   SHWR_EVT_CTR <= SHWR_EVT_CTR+1;
                   TRIGGERED <= 0;
                   
                   // Save address to start of trace
                   LCL_SHWR_BUF_STARTN[SHWR_BUF_WNUM] <= SHWR_ADDR;
                end // if (SHWR_TRIG_DLYD[`SHWR_TRIG_DLY] < SHWR_TRIG_DLYD[`SHWR_TRIG_DLY-1])
           end
           else
             SHWR_TRIGGER <= 0;
        end 

        
        // Process clearing of shower buf full flag
        PREV_SHWR_CONTROL_WRITTEN <= LCL_SHWR_CONTROL_WRITTEN;
        if ((PREV_SHWR_CONTROL_WRITTEN & !LCL_SHWR_CONTROL_WRITTEN) == 1)
          begin
             SHWR_BUF_RESET  
               = (1<<LCL_SHWR_BUF_CONTROL) & SHWR_BUF_FULL_FLAGS;
             if ((SHWR_BUF_RESET != 0) 
                 && (LCL_SHWR_BUF_CONTROL == SHWR_BUF_RNUM))
               begin
                  LCL_SHWR_BUF_TRIG_IDN[SHWR_BUF_RNUM] <= 0;
                  SHWR_BUF_FULL_FLAGS <= SHWR_BUF_FULL_FLAGS & 
                                         ~SHWR_BUF_RESET;
                  SHWR_BUF_NUM_FULL <= SHWR_BUF_NUM_FULL-1;
                  SHWR_BUF_RNUM <= SHWR_BUF_RNUM+1;
                  // Reset shwr intr pending if resetting last filled buffer
	          if (SHWR_BUF_NUM_FULL == 1) SHWR_INTR <= 0;
               end
          end // if ((PREV_SHWR_CONTROL_WRITTEN & !LCL_SHWR_CONTROL_WRITTEN) == 1)
        else
          SHWR_BUF_RESET <= 0;
                
        // Process loading information into status registers
        
        // Load ID register with compile date. 
        ID_REG <= `COMPILE_DATE;

        // Process loading of status registers from internal registers

        // Load shower buffer status register 
        // Load as sub-register as alternative to test timing performance
        LCL_SHWR_BUF_STATUS[`SHWR_BUF_WNUM_SHIFT+`SHWR_BUF_NUM_WIDTH-1:
                            `SHWR_BUF_WNUM_SHIFT] <= SHWR_BUF_WNUM;
        LCL_SHWR_BUF_STATUS[`SHWR_BUF_RNUM_SHIFT+`SHWR_BUF_NUM_WIDTH-1:
                            `SHWR_BUF_RNUM_SHIFT] <= SHWR_BUF_RNUM;
        LCL_SHWR_BUF_STATUS[`SHWR_BUF_FULL_SHIFT+`SHWR_MEM_NBUF-1:
                            `SHWR_BUF_FULL_SHIFT] <= SHWR_BUF_FULL_FLAGS;
        LCL_SHWR_BUF_STATUS[`SHWR_INTR_PEND_SHIFT:
                            `SHWR_INTR_PEND_SHIFT] <= SHWR_INTR;
        LCL_SHWR_BUF_STATUS[`SHWR_BUF_NFULL_SHIFT+`SHWR_BUF_NUM_WIDTH:
                            `SHWR_BUF_NFULL_SHIFT] <= SHWR_BUF_NUM_FULL;
        LCL_SHWR_BUF_STATUS[31:`SHWR_BUF_NOTUSED_SHIFT] <= 0;

        // Send debug output to test pins P61 through P65

	P6X[1] <= LED_DEBUG[0];
	P6X[2] <= LED_DEBUG[1];
	P6X[3] <= LED_DEBUG[2];
	P6X[4] <= LED_DEBUG[3];
	P6X[5] <= LED_DEBUG[4];
        
     end // else: !if(LCL_RESET)
end

   always @( posedge S_AXI_ACLK )
     begin
        if (slv_reg_wren &&
            ( axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] 
              == `SHWR_BUF_CONTROL_ADDR ))
          AXI_SHWR_CONTROL_WRITTEN <= 1;
        else
          AXI_SHWR_CONTROL_WRITTEN <= 0;
        if (slv_reg_wren &&
            ( axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] 
              == `MUON_BUF_CONTROL_ADDR ))
          AXI_MUON_CONTROL_WRITTEN <= 1;
        else
          AXI_MUON_CONTROL_WRITTEN <= 0;
        AXI_REG_WRITE <= slv_reg_wren;
     end


   // Synchronization with AXI registers for cases where glitches would be
   // problematic.  This should not be necessary for semi-static control registers.

   synchronizer_32bit compatibility_global_control_sync
     (.ASYNC_IN(COMPATIBILITY_GLOBAL_CONTROL),
      .CLK(CLK120),
      .SYNC_OUT(LCL_COMPATIBILITY_GLOBAL_CONTROL));
   synchronizer_32bit shwr_buf_control_sync(.ASYNC_IN(SHWR_BUF_CONTROL),
                                            .CLK(CLK120),
                                            .SYNC_OUT(LCL_SHWR_BUF_CONTROL));
   synchronizer_32bit led__control_sync(.ASYNC_IN(LED_CONTROL),
                                            .CLK(CLK120),
                                            .SYNC_OUT(LCL_LED_CONTROL));
   synchronizer_1bit control_written_sync(.ASYNC_IN(AXI_SHWR_CONTROL_WRITTEN),
                                          .CLK(CLK120),
                                          .SYNC_OUT(LCL_SHWR_CONTROL_WRITTEN));

   synchronizer_32bit shwr_trigid_sync
     (.ASYNC_IN(LCL_SHWR_BUF_TRIG_ID),
      .CLK(S_AXI_ACLK),.SYNC_OUT(SHWR_BUF_TRIG_ID));
   synchronizer_32bit shwr_buf_status_sync
     (.ASYNC_IN(LCL_SHWR_BUF_STATUS),
      .CLK(S_AXI_ACLK),.SYNC_OUT(SHWR_BUF_STATUS));
   synchronizer_32bit shwr_buf_start_sync
     (.ASYNC_IN(LCL_SHWR_BUF_START),
      .CLK(S_AXI_ACLK),.SYNC_OUT(SHWR_BUF_START));


   // Test ADC outputs
   synchronizer_32bit adc0_test_sync
     (.ASYNC_IN({4'b0000,ADC0[2*`ADC_WIDTH-1:`ADC_WIDTH],
                 4'b0000,ADC0[`ADC_WIDTH-1:0]}),
      .CLK(S_AXI_ACLK),.SYNC_OUT(ADC0_TEST));
   synchronizer_32bit adc1_test_sync
     (.ASYNC_IN({4'b0000,ADC1[2*`ADC_WIDTH-1:`ADC_WIDTH],
                 4'b0000,ADC1[`ADC_WIDTH-1:0]}),
      .CLK(S_AXI_ACLK),.SYNC_OUT(ADC1_TEST));
   synchronizer_32bit adc2_test_sync
     (.ASYNC_IN({4'b0000,ADC2[2*`ADC_WIDTH-1:`ADC_WIDTH],
                 4'b0000,ADC2[`ADC_WIDTH-1:0]}),
      .CLK(S_AXI_ACLK),.SYNC_OUT(ADC2_TEST));
   synchronizer_32bit adc3_test_sync
     (.ASYNC_IN({4'b0000,ADC3[2*`ADC_WIDTH-1:`ADC_WIDTH],
                 4'b0000,ADC3[`ADC_WIDTH-1:0]}),
      .CLK(S_AXI_ACLK),.SYNC_OUT(ADC3_TEST));
   synchronizer_32bit adc4_test_sync
     (.ASYNC_IN({4'b0000,ADC4[2*`ADC_WIDTH-1:`ADC_WIDTH],
                 4'b0000,ADC4[`ADC_WIDTH-1:0]}),
      .CLK(S_AXI_ACLK),.SYNC_OUT(ADC4_TEST));

   // Test filtered ADC outputs
   synchronizer_32bit filt_pmt0_test_sync
     (.ASYNC_IN({2'b00,FILTD_PMT0,4'b0000,FILTB_PMT0}),
      .CLK(S_AXI_ACLK),.SYNC_OUT(FILT_PMT0_TEST));
   synchronizer_32bit filt_pmt1_test_sync
     (.ASYNC_IN({2'b00,FILTD_PMT1,4'b0000,FILTB_PMT1}),
      .CLK(S_AXI_ACLK),.SYNC_OUT(FILT_PMT1_TEST));
   synchronizer_32bit filt_pmt2_test_sync
     (.ASYNC_IN({2'b00,FILTD_PMT2,4'b0000,FILTB_PMT2}),
      .CLK(S_AXI_ACLK),.SYNC_OUT(FILT_PMT2_TEST));

   // These are mostly redundant, but may be useful for debugging
   // synchronizer_32bit shwr_buf_start0_sync
   //   (.ASYNC_IN(LCL_SHWR_BUF_START0),
   //    .CLK(S_AXI_ACLK),.SYNC_OUT(`SHWR_BUF_START0));
   // synchronizer_32bit shwr_buf_start1_sync
   //   (.ASYNC_IN(LCL_SHWR_BUF_START1),
   //    .CLK(S_AXI_ACLK),.SYNC_OUT(`SHWR_BUF_START1));
   // synchronizer_32bit shwr_buf_start2_sync
   //   (.ASYNC_IN(LCL_SHWR_BUF_START2),
   //    .CLK(S_AXI_ACLK),.SYNC_OUT(`SHWR_BUF_START2));
   // synchronizer_32bit shwr_buf_start3_sync
   //   (.ASYNC_IN(LCL_SHWR_BUF_START3),
   //    .CLK(S_AXI_ACLK),.SYNC_OUT(`SHWR_BUF_START3));

